/* -------------------------------------------
   FMOD Studio Script by Tanz0rz:
   Export event names as Haxe constants
   -------------------------------------------
 */

const generatedInfoHeader = "/*\r\n    DO NOT EDIT THIS FILE DIRECTLY\r\n"
    + "    This file was generated by a script in FMOD Studio \r\n" 
    + "*/\r\n\r\n"

studio.menu.addMenuItem({ 
    name: "Export Enums and Build",  
    execute: function() {displayDirectoryPickerModal()},
    keySequence: "Ctrl+B",
});

const constantsFileName = "FmodConstants.hx";
const enumsFileName = "FmodEnums.hx";
const cacheFileName = "CachedHaxeOutputChoices";

function displayDirectoryPickerModal() {

    var userChoices = loadUserChoicesFromFile();

    studio.ui.showModalDialog({
        windowTitle: "Generate Haxe Files",
        windowWidth: 800,
        windowHeight: 0,
        widgetType: studio.ui.widgetType.Layout,
        layout: studio.ui.layoutType.VBoxLayout,
        items: [
            // --- Generation options ---
            {
                widgetType: studio.ui.widgetType.Layout,
                layout: studio.ui.layoutType.VBoxLayout,
                contentsMargins: { left: 0, top: 0, right: 0, bottom: 0 },
                items: [
                    // Const option
                    {
                        widgetType: studio.ui.widgetType.CheckBox,
                        widgetId: "m_generateConstants",
                        text: "Generate String Constants (Recommended)",
                        isChecked: userChoices.generateConsts
                    },
                    {
                        widgetType: studio.ui.widgetType.Label,
                        text:
                            "String constants. This is the most simple to use and is recommended for\n" +
                            "most users.",
                        wordWrap: true,
                        enabled: false,           // visually de-emphasized
                        contentsMargins: { left: 22, top: 2, right: 0, bottom: 0 }
                    },

                    // Small vertical gap
                    {
                        widgetType: studio.ui.widgetType.Spacer,
                        sizePolicy: {
                            verticalPolicy: studio.ui.sizePolicy.Fixed
                        },
                        minimumHeight: 8
                    },

                    // Enum option
                    {
                        widgetType: studio.ui.widgetType.CheckBox,
                        widgetId: "m_generateEnums",
                        text: "Generate Enums (Advanced)",
                        isChecked: userChoices.generateEnums
                    },
                    {
                        widgetType: studio.ui.widgetType.Label,
                        text:
                            "Enums with path mapping. Useful in certain situations/patterns.",
                        wordWrap: true,
                        enabled: false,           // visually de-emphasized
                        contentsMargins: { left: 22, top: 2, right: 0, bottom: 0 }
                    }
                ]
            },

            {
                widgetType: studio.ui.widgetType.Spacer,
                sizePolicy: {
                    horizontalPolicy: studio.ui.sizePolicy.MinimumExpanding
                },
                minimumHeight: 8
            },

            // --- Directory picker + Save ---
            {
                widgetType: studio.ui.widgetType.Layout,
                layout: studio.ui.layoutType.VBoxLayout,
                contentsMargins: { left: 0, top: 0, right: 0, bottom: 0 },
                items: [
                    {
                        widgetType: studio.ui.widgetType.Label,
                        text: "Select the folder with your Haxe project's Main class",
                        wordWrap: true,
                        enabled: false,           // visually de-emphasized
                        contentsMargins: { left: 22, top: 2, right: 0, bottom: 0 }
                    },
                    {
                        widgetType: studio.ui.widgetType.Layout,
                        layout: studio.ui.layoutType.HBoxLayout,
                        contentsMargins: { left: 0, top: 0, right: 0, bottom: 0 },
                        items: [
                            {
                                widgetType: studio.ui.widgetType.PathLineEdit,
                                stretchFactor: 1,
                                widgetId: "m_directoryPicker",
                                text: userChoices.outputDir,
                                pathType: studio.ui.pathType.Directory,
                            },
                            {
                                widgetType: studio.ui.widgetType.PushButton,
                                text: "Generate",
                                onClicked: function () {
                                    var generateConstants =
                                        this.findWidget("m_generateConstants").isChecked();
                                    var generateEnums =
                                        this.findWidget("m_generateEnums").isChecked();

                                    if (!generateConstants && !generateEnums) {
                                        alert(
                                            "Please select at least one output type."
                                        );
                                        return;
                                    }

                                    createHaxeFiles(
                                        this,
                                        generateConstants,
                                        generateEnums
                                    );

                                    console.log("Building banks...");
                                    studio.project.build();
                                    this.closeDialog();
                                }
                            }
                        ]
                    }
                ]
            }
        ]
    });
};

function createHaxeFiles(dialog, generateConstants, generateEnums) {
    var outputPath = dialog.findWidget("m_directoryPicker").text();
    if (generateConstants) {
        const fullOutputPath = "{0}/{1}".format(outputPath, constantsFileName);
        var haxeFile = studio.system.getFile(fullOutputPath);
        if (!haxeFile.open(studio.system.openMode.WriteOnly)) {    
            alert("Failed to open constants file for writing: " + fullOutputPath + "\n\nCheck the file is not read-only.");
            console.error("Failed to open constants file for writing: " + fullOutputPath);
            return;
        }

        console.log("Opened file: " + fullOutputPath);
        writeConstantsFileBody(haxeFile);
        haxeFile.close();
    }

    if (generateEnums) {
        const fullOutputPath = "{0}/{1}".format(outputPath, enumsFileName);
        var haxeFile = studio.system.getFile(fullOutputPath);
        if (!haxeFile.open(studio.system.openMode.WriteOnly)) {    
            alert("Failed to open constants file for writing: " + fullOutputPath + "\n\nCheck the file is not read-only.");
            console.error("Failed to open constants file for writing: " + fullOutputPath);
            return;
        }

        console.log("Opened file: " + fullOutputPath);
        writeEnumFileBody(haxeFile);
        haxeFile.close();
    }

    saveUserChoicesToFile(outputPath, generateConstants, generateEnums);

    alert("Haxe file(s) successfully created in:\n\n" + outputPath);
    console.log("Haxe file(s) successfully created in: " + outputPath);
}

function loadUserChoicesFromFile() {
    const path =
        studio.project.filePath.substr(
            0,
            studio.project.filePath.lastIndexOf("/") + 1
        ) + cacheFileName;

    var file = studio.system.getFile(path);
    if (!file.exists() || !file.open(studio.system.openMode.ReadOnly)) {
        return {
            outputDir: "",
            generateEnums: false,
            generateConsts: true
        };
    }

    var text = file.readText(file.size());
    file.close();

    // Old format: plain string
    if (text[0] !== "{") {
        return {
            outputDir: text,
            generateEnums: false,
            generateConsts: true
        };
    }

    try {
        return JSON.parse(text);
    } catch (e) {
        console.error("Failed to parse cache file:", e);
        return null;
    }
}

function saveUserChoicesToFile(outputDir, generateEnums, generateConsts) {
    const haxeSystemInformationFileLocation =
        studio.project.filePath.substr(
            0,
            studio.project.filePath.lastIndexOf("/") + 1
        ) + cacheFileName;

    var haxeSystemInformationFile =
        studio.system.getFile(haxeSystemInformationFileLocation);

    if (!haxeSystemInformationFile.open(studio.system.openMode.WriteOnly)) {
        alert("Failed to open file to cache selected directory: " + haxeSystemInformationFile);
        console.error("Failed to open file to cache selected directory: " + haxeSystemInformationFile);
        return;
    }

    var data = {
        outputDir: outputDir,
        generateEnums: !!generateEnums,
        generateConsts: !!generateConsts
    };

    haxeSystemInformationFile.writeText(
        JSON.stringify(data, null, 2)
    );

    haxeSystemInformationFile.close();
}

function sortByPath(a, b) {
    var pathA = a.getPath().toUpperCase();
    var pathB = b.getPath().toUpperCase();

    if (pathA < pathB) {
        return -1;
    }
    if (pathA > pathB) {
        return 1;        
    }
    return 0;
}

function sanitizePath(rawPath) {
    // If the path segment starts with a number, prefix an underscore
    // Replace any whitespace in the path with underscores
    return rawPath.replace(/(^[0-9])/g, "_$1").replace(/ /g, "_");
}

function getAllEvents() {
    // Read all events in from FMOD Studio project
    var allEvents = studio.project.model.Event.findInstances();
    if (allEvents.length === 0) {
        return;
    }

    // Sort events alphabetically 
    allEvents.sort(function(a, b) {
        var pathA = a.getPath().toUpperCase();
        var pathB = b.getPath().toUpperCase();

        if (pathA < pathB) {
            return -1;
        }
        if (pathA > pathB) {
            return 1;        
        }
        return 0;
    });

    return allEvents;
}

function getAllBusses() {
        var allBusInstances = studio.project.model.MixerGroup.findInstances();
    allBusInstances.sort(sortByPath);

    // The master bus path is "bus:/" and not included in the mixer group instances
    var allBusses = [{'path': "bus:/", 'name': "Master"}];

    allBusInstances.forEach(function(object) {
        var path = sanitizePath(object.getPath());
        console.log("Bus Path: " + path);

        var finalSlashIndex = path.lastIndexOf('/');
        var busName = path.substring(finalSlashIndex + 1);

        allBusses.push({'path': path, 'name': busName});
    });

    return allBusses;
}

function writeConstantsFileBody(constantsFile) {
    constantsFile.writeText("package;\r\n\r\n")

    // Write header for file
    constantsFile.writeText(generatedInfoHeader);

    var allEvents = studio.project.model.Event.findInstances();
    allEvents.sort(sortByPath);

    var allMusic = [];
    var allSfx = [];

    allEvents.forEach(function(object) {
        var path = sanitizePath(object.getPath());
        console.log("Event Path: " + path);

        var finalSlashIndex = path.lastIndexOf('/');
        var eventName = path.substring(finalSlashIndex + 1);
        if (path.split('/')[1] == "Music") {
            allMusic.push({'path': path, 'name': eventName});
        } else if (path.split('/')[1] == "SFX") {
            allSfx.push({'path': path, 'name': eventName});
        }
    })

    var allBusses = getAllBusses();

    // Generate constants for music events
    console.log("Exporting Music events")
    constantsFile.writeText("class FmodSongs {\r\n");
    allMusic.forEach(function(event) {
        constantsFile.writeText("    public static inline var " + event.name + ":String = \"" + event.path + "\";\r\n");
    });
    constantsFile.writeText("}\r\n\r\n");
    
    // Generate constants for sfx events
    console.log("Exporting SFX events")
    constantsFile.writeText("class FmodSFX {\r\n");
    allSfx.forEach(function(event) {
        constantsFile.writeText("    public static inline var " + event.name + ":String = \"" + event.path + "\";\r\n");
    });
    constantsFile.writeText("}\r\n");

    // Generate constants for busses
    console.log("Exporting Busses")
    constantsFile.writeText("class FmodBus {\r\n");
    allBusses.forEach(function(obj) {
        constantsFile.writeText("    public static inline var " + obj.name + ":String = \"" + obj.path + "\";\r\n");
    });
    constantsFile.writeText("}\r\n");
}

function writeEnumFileBody(file) {
    file.writeText("package;\r\n\r\n");

    // Write header for file
    file.writeText("/*\r\n    DO NOT EDIT THIS FILE DIRECTLY\r\n"
    + "    This file was generated by a script in FMOD Studio \r\n*/\r\n\r\n");
    file.writeText("// @formatter:off\r\n");

    // ---- Events ----

    var allEvents = studio.project.model.Event.findInstances();
    allEvents.sort(sortByPath);

    var allMusic = [];
    var allSfx = [];

    allEvents.forEach(function(object) {
        var path = sanitizePath(object.getPath());
        console.log("Event Path: " + path);

        var finalSlashIndex = path.lastIndexOf('/');
        var eventName = path.substring(finalSlashIndex + 1);
        if (path.split('/')[1] == "Music") {
            allMusic.push({'path': path, 'name': eventName});
        } else if (path.split('/')[1] == "SFX") {
            allSfx.push({'path': path, 'name': eventName});
        }
    })

    // ---- Busses ----

    var allBusses = getAllBusses();

    // ---- Write enums ----

    console.log("Exporting music event enum");
    file.writeText("enum FmodSongE {\r\n");
    allMusic.forEach(function(event) {
        file.writeText("    " + event.name + ";\r\n");
    });
    file.writeText("}\r\n\r\n");
    
    console.log("Exporting SFX event enum");
    file.writeText("enum FmodSFXE {\r\n");
    allSfx.forEach(function(event) {
        file.writeText("    " + event.name + ";\r\n");
    });
    file.writeText("}\r\n\r\n");

    console.log("Exporting bus enum");
    file.writeText("enum FmodBusE {\r\n");
    allBusses.forEach(function(bus) {
        file.writeText("    " + bus.name + ";\r\n");
    });
    file.writeText("}\r\n\r\n");

    // ---- Write path util class ----

    console.log("Exporting path util class and functions");
    file.writeText("class FmodPath {\r\n");

    file.writeText("    public static inline extern overload function path(song:FmodSongE):String {\r\n");
    file.writeText("        return switch(song) {\r\n");
    allMusic.forEach(function(event) {
        file.writeText("            case " + event.name + ": \"" + event.path + "\";\r\n");
    });
    file.writeText("        }\r\n");
    file.writeText("    }\r\n");

    file.writeText("    public static inline extern overload function path(sfx:FmodSFXE):String {\r\n");
    file.writeText("        return switch(sfx) {\r\n");
    allSfx.forEach(function(event) {
        file.writeText("            case " + event.name + ": \"" + event.path + "\";\r\n");
    });
    file.writeText("        }\r\n");
    file.writeText("    }\r\n");

    file.writeText("    public static inline extern overload function path(bus:FmodBusE):String {\r\n");
    file.writeText("        return switch(bus) {\r\n");
    allBusses.forEach(function(bus) {
        file.writeText("            case " + bus.name + ": \"" + bus.path + "\";\r\n");
    });
    file.writeText("        }\r\n");
    file.writeText("    }\r\n");

    file.writeText("}\r\n");
}